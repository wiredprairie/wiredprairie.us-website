{"id":380,"date":"2008-06-25T07:38:55","date_gmt":"2008-06-25T12:38:55","guid":{"rendered":"http:\/\/www.wiredprairie.us\/blog\/index.php\/archives\/380"},"modified":"2008-06-25T07:38:55","modified_gmt":"2008-06-25T12:38:55","slug":"coding-challenge-11","status":"publish","type":"post","link":"https:\/\/www.wiredprairie.us\/blog\/index.php\/archives\/380","title":{"rendered":"Coding Challenge #11"},"content":{"rendered":"<p><a href=\"http:\/\/www.wiredprairie.us\/blog\/index.php\/archives\/128\">Coding Challenge Series<\/a> \/ <a href=\"http:\/\/www.wiredprairie.us\/blog\/index.php\/archives\/128\">Technical Interview Series<\/a><\/p>\n<p>A function you create is provided as a parameter a string of arbitrary length. This string has special characteristics though &#8212; once a character is read, it is zeroed out and is then read-only. <\/p>\n<p>You may access the string&#8217;s individual characters either as an array or a function (whichever your programming language supports, for example string[#] or string.getChar(#)); no other built-in string functions may be used. <\/p>\n<p>The function you create must do the following:<\/p>\n<ul>\n<li>Find the longest segment delimited by a character, provided as a second parameter to the function <\/li>\n<li>The start of the string and the end of the string should be treated as if they are the delimiter character.<\/li>\n<li>Return the longest segment as a new string. <\/li>\n<li>Your function may not make a copy of the entire string (only if it matches the long segment).<\/li>\n<li>If two segments are the same length, return the last one found.<\/li>\n<\/ul>\n","protected":false},"excerpt":{"rendered":"<p>Coding Challenge Series \/ Technical Interview Series A function you create is provided as a parameter a string of arbitrary length. This string has special characteristics though &#8212; once a character is read, it is zeroed out and is then read-only. You may access the string&#8217;s individual characters either as an array or a function [&hellip;]<\/p>\n","protected":false},"author":2,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"spay_email":"","jetpack_publicize_message":"","jetpack_is_tweetstorm":false,"jetpack_publicize_feature_enabled":true},"categories":[10],"tags":[],"jetpack_publicize_connections":[],"jetpack_featured_media_url":"","jetpack_sharing_enabled":true,"jetpack_shortlink":"https:\/\/wp.me\/pd5QIe-68","jetpack_likes_enabled":true,"jetpack-related-posts":[{"id":449,"url":"https:\/\/www.wiredprairie.us\/blog\/index.php\/archives\/449","url_meta":{"origin":380,"position":0},"title":"Coding Challenge #17","date":"August 6, 2008","format":false,"excerpt":"Coding Challenge Series \/ Technical Interview Series You are writing code for an embedded system. There are some restrictions on memory and I\/O that you must follow. Your challenge is to create a file search function. The function is provided an ASCII string and the name of the file. The\u2026","rel":"","context":"In &quot;Coding&quot;","img":{"alt_text":"","src":"","width":0,"height":0},"classes":[]},{"id":395,"url":"https:\/\/www.wiredprairie.us\/blog\/index.php\/archives\/395","url_meta":{"origin":380,"position":1},"title":"Coding Challenge #12","date":"July 2, 2008","format":false,"excerpt":"Coding Challenge Series \/ Technical Interview Series Decode a HTML URL encoded string. A URL encoded string is a series of characters, where the sequence %## is a single byte hex encoded character. Hi%20there! becomes Hi there! Do not use any standard function for hex or decoding functions that may\u2026","rel":"","context":"In &quot;Interview&quot;","img":{"alt_text":"","src":"","width":0,"height":0},"classes":[]},{"id":493,"url":"https:\/\/www.wiredprairie.us\/blog\/index.php\/archives\/493","url_meta":{"origin":380,"position":2},"title":"Coding Challenge #20!","date":"August 27, 2008","format":false,"excerpt":"Coding Challenge Series \/ Technical Interview Series Write a function to return a specified number of words from a string (as a new string), up to a maximum of specified characters total. Your function is passed the original string, the number of words to return, and the maximum number of\u2026","rel":"","context":"In &quot;Interview&quot;","img":{"alt_text":"","src":"","width":0,"height":0},"classes":[]},{"id":459,"url":"https:\/\/www.wiredprairie.us\/blog\/index.php\/archives\/459","url_meta":{"origin":380,"position":3},"title":"Coding Challenge #18","date":"August 13, 2008","format":false,"excerpt":"Coding Challenge Series \/ Technical Interview Series Compare two strings ignoring spaces, line feeds, and carriage returns. You may not change or make a copy of either string. Strings are identical if all characters are exactly the same (ignoring the previously mentioned characters). (Yes, this may not be terribly difficult,\u2026","rel":"","context":"In &quot;Interview&quot;","img":{"alt_text":"","src":"","width":0,"height":0},"classes":[]},{"id":429,"url":"https:\/\/www.wiredprairie.us\/blog\/index.php\/archives\/429","url_meta":{"origin":380,"position":4},"title":"Coding Challenge #15","date":"July 23, 2008","format":false,"excerpt":"Coding Challenge Series \/ Technical Interview Series Create a structure which represents a binary tree. Iterate through all of the elements of the tree in any order, without using recursion. Update: Your function is only provided the root of the constructed tree. A tree node should contain no more than\u2026","rel":"","context":"In &quot;Interview&quot;","img":{"alt_text":"","src":"","width":0,"height":0},"classes":[]},{"id":400,"url":"https:\/\/www.wiredprairie.us\/blog\/index.php\/archives\/400","url_meta":{"origin":380,"position":5},"title":"Coding Challenge #13","date":"July 9, 2008","format":false,"excerpt":"Coding Challenge Series \/ Technical Interview Series You have a list of strings. Eliminate duplicates. Sure, simple enough if the list is small. What if the list has thousands of entries? A simple solution simply :) won't do.","rel":"","context":"In &quot;Interview&quot;","img":{"alt_text":"","src":"","width":0,"height":0},"classes":[]}],"_links":{"self":[{"href":"https:\/\/www.wiredprairie.us\/blog\/index.php\/wp-json\/wp\/v2\/posts\/380"}],"collection":[{"href":"https:\/\/www.wiredprairie.us\/blog\/index.php\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.wiredprairie.us\/blog\/index.php\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.wiredprairie.us\/blog\/index.php\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/www.wiredprairie.us\/blog\/index.php\/wp-json\/wp\/v2\/comments?post=380"}],"version-history":[{"count":0,"href":"https:\/\/www.wiredprairie.us\/blog\/index.php\/wp-json\/wp\/v2\/posts\/380\/revisions"}],"wp:attachment":[{"href":"https:\/\/www.wiredprairie.us\/blog\/index.php\/wp-json\/wp\/v2\/media?parent=380"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.wiredprairie.us\/blog\/index.php\/wp-json\/wp\/v2\/categories?post=380"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.wiredprairie.us\/blog\/index.php\/wp-json\/wp\/v2\/tags?post=380"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}